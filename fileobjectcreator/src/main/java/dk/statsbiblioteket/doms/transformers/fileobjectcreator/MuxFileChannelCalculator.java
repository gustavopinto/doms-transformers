package dk.statsbiblioteket.doms.transformers.fileobjectcreator;

import dk.statsbiblioteket.doms.transformers.common.autogenerated.Channel;

import javax.xml.datatype.DatatypeConfigurationException;
import javax.xml.datatype.DatatypeFactory;
import javax.xml.datatype.XMLGregorianCalendar;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

public class MuxFileChannelCalculator {

    private final Set<Channel> muxChannels1 = new HashSet<Channel>();
    private final Set<Channel> muxChannels2 = new HashSet<Channel>();

    public MuxFileChannelCalculator(InputStream muxChannelsStream) throws IOException, ParseException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(muxChannelsStream));
        String line;
        //2009-10-30 10:50:00.0
        DateFormat format = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.S");
        while ((line = reader.readLine()) != null){
            line = line.trim();
            if (line.length() == 0){
                continue;
            }
            String[] splits = line.split(",");
            Date start = format.parse(splits[3]);
            Date stop = format.parse(splits[4]);

            try {
                DatatypeFactory datatypeFactory = DatatypeFactory.newInstance();

                GregorianCalendar gregorianCalendar = new GregorianCalendar();

                gregorianCalendar.setTime(start);
                XMLGregorianCalendar startGreg = datatypeFactory.newXMLGregorianCalendar(gregorianCalendar);

                gregorianCalendar.setTime(stop);
                XMLGregorianCalendar stopGreg = datatypeFactory.newXMLGregorianCalendar(gregorianCalendar);

                Channel channel = new Channel();
                channel.setChannelID(splits[1]);
                channel.setMuxProgramNr(Integer.parseInt(splits[2]));
                channel.setStartTime(startGreg);
                channel.setStopTime(stopGreg);

                getMuxChannelsFromMuxNumber(Integer.parseInt(splits[0])).add(channel);

            } catch (DatatypeConfigurationException e) {
                throw new IOException(e.getMessage(), e.getCause());
            }
        }
    }


    public List<Channel> getChannelIDsForMux(int muxNumber, Date startDate){
        List<Channel> results = new ArrayList<Channel>();
        for (Channel channel : getMuxChannelsFromMuxNumber(muxNumber)) {
            if (channel.getStartTime().toGregorianCalendar().getTime().before(startDate)
                    && channel.getStopTime().toGregorianCalendar().getTime().after(startDate)) {
                Channel newChannel = new Channel();
                newChannel.setChannelID(channel.getChannelID());
                newChannel.setMuxProgramNr(channel.getMuxProgramNr());
                results.add(newChannel);
            }
        }
        return results;
    }

    public List<Channel> getChannelIDsForMux(int muxNumber, XMLGregorianCalendar xmlGregorianCalendar) {
        return getChannelIDsForMux(muxNumber, xmlGregorianCalendar.toGregorianCalendar().getTime());
    }

    private Set<Channel> getMuxChannelsFromMuxNumber(int muxNumber) {
        switch (muxNumber) {
            case 1:
                return muxChannels1;
            case 2:
                return muxChannels2;
            default:
                return null;
        }
    }
}
